#
# Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

jshell.msg.welcome =\
Welcome to JShell -- Version {0}\n\
For an introduction type: /help intro
jshell.err.opt.arg = Argument to {0} missing.
jshell.err.opt.invalid = Invalid options: {0}.
jshell.err.opt.one = Only one {0} option may be used.
jshell.err.opt.startup.conflict = Conflicting options: both --startup and --no-startup were used.
jshell.err.opt.feedback.one = Only one feedback option (--feedback, -q, -s, or -v) may be used.
jshell.err.opt.unknown = Unknown option: {0}

jshell.msg.terminated = State engine terminated.
jshell.msg.terminated.restore = Restore definitions with: /reload -restore

jshell.msg.use.one.of = Use one of: {0}
jshell.msg.see.classes.etc = See /types, /methods, /vars, or /list
jshell.err.arg = Invalid ''{0}'' argument: {1}
jshell.msg.see = See {0} for help.

jshell.err.file.not.accessible = File ''{1}'' for ''{0}'' is not accessible: {2}
jshell.err.file.not.found = File ''{1}'' for ''{0}'' is not found.
jshell.err.file.exception = File ''{1}'' for ''{0}'' threw exception: {2}
jshell.err.file.filename = ''{0}'' requires a filename argument.

jshell.err.startup.unexpected.exception = Unexpected exception reading start-up: {0}
jshell.err.unexpected.exception = Unexpected exception: {0}

jshell.err.invalid.command = Invalid command: {0}
jshell.err.command.ambiguous = Command: ''{0}'' is ambiguous: {1}
jshell.msg.set.restore = Setting new options and restoring state.
jshell.msg.set.editor.set = Editor set to: {0}
jshell.msg.set.editor.retain = Editor setting retained: {0}
jshell.err.no.builtin.editor = Built-in editor not available.
jshell.err.cant.launch.editor = Cannot launch built-in editor -- unexpected exception: {0}
jshell.msg.try.set.editor = See ''/help /set editor'' to use external editor.
jshell.msg.press.return.to.leave.edit.mode = Press return to leave edit mode.
jshell.err.wait.applies.to.external.editor = -wait applies to external editors
jshell.label.editpad = JShell Edit Pad

jshell.err.setting.to.retain.must.be.specified = The setting to retain must be specified -- {0}
jshell.msg.set.show.mode.settings = \nTo show mode settings use ''/set prompt'', ''/set truncation'', ...\n\
or use ''/set mode'' followed by the feedback mode name.
jshell.err.continuation.prompt.required = Continuation prompt required -- {0}

jshell.msg.try.command.without.args = Try ''{0}'' without arguments.
jshell.msg.no.active = There are no active definitions.

jshell.msg.resetting = Resetting...
jshell.msg.resetting.state = Resetting state.

jshell.err.reload.no.previous = No previous history to restore
jshell.err.reload.restarting.previous.state = Restarting and restoring from previous state.
jshell.err.reload.restarting.state = Restarting and restoring state.

jshell.err.restart.failed = Restart failed: {0}\n\n\
Reverting to previous settings and restarting...

jshell.msg.vars.not.active = (not-active)

jshell.err.out.of.range = Out of range

jshell.msg.error = Error:
jshell.msg.warning = Warning:

jshell.err.sub.arg = The ''{0}'' command requires a sub-command. See: ''/help {0}''
jshell.err.sub.ambiguous = Ambiguous sub-command argument to ''{0}'': {1}

jshell.err.classpath.arg = The /classpath command requires a path argument.
jshell.msg.classpath = Path ''{0}'' added to classpath

jshell.err.help.arg = No commands or subjects start with the provided argument: {0}
jshell.msg.help.begin =\
Type a Java language expression, statement, or declaration.\n\
Or type one of the following commands:\n
jshell.msg.help.subject =\n\
For more information type ''/help'' followed by the name of a\n\
command or a subject.\n\
For example ''/help /list'' or ''/help intro''.\n\
\n\
Subjects:\n\
\n

jshell.err.no.snippet.with.id = No snippet with id: {0}
jshell.err.end.snippet.range.less.than.start = End of snippet range less than start: {0} - {1}
jshell.err.range.requires.id = Snippet ranges require snippet ids: {0}

jshell.err.exit.not.expression = The argument to /exit must be a valid integer expression, it is not an expression: {0}
jshell.err.exit.bad.type = The argument to /exit must be a valid integer expression. The type is {1} : {0}
jshell.err.exit.bad.value = The argument to /exit has bad value is {1} : {0}

jshell.err.drop.arg =\
In the /drop argument, please specify an import, variable, method, or class to drop.\n\
Specify by id or name. Use /list to see ids. Use /reset to reset all state.
jshell.err.failed = Failed.
jshell.msg.native.method = Native Method
jshell.msg.unknown.source = Unknown Source
jshell.msg.goodbye = Goodbye
jshell.msg.goodbye.value = Goodbye ({0})

jshell.msg.help.for.help = Type /help for help.

jshell.err.mode.name = Expected a feedback mode name: {0}
jshell.err.missing.mode = Missing the feedback mode -- {0}
jshell.err.field.name = Expected a field name: {0} -- {1}
jshell.err.mode.unknown = No feedback mode named: {0} -- {1}

jshell.err.feedback.does.not.match.mode = Does not match any current feedback mode: {0} -- {1}
jshell.err.feedback.ambiguous.mode = Matches more then one current feedback mode: {0} -- {1}
jshell.err.feedback.must.be.quoted = Format ''{0}'' must be quoted -- {1}
jshell.err.feedback.not.a.valid.selector = Not a valid selector ''{0}'' in ''{1}'' -- {2}
jshell.err.feedback.multiple.sections = Selector kind in multiple sections of selector list ''{0}'' in ''{1}'' -- {2}
jshell.err.feedback.different.selector.kinds = Different selector kinds in same sections of selector list ''{0}'' in ''{1}'' -- {2}

jshell.msg.feedback.new.mode = Created new feedback mode: {0}
jshell.msg.feedback.mode = Feedback mode: {0}
jshell.msg.feedback.mode.following = Available feedback modes:
jshell.msg.feedback.retained.mode.following = Retained feedback modes:
jshell.err.mode.creation = To create a new mode either the -command or the -quiet option must be used -- {0}
jshell.err.mode.exists = Mode to be created already exists: {0} -- {1}

jshell.err.truncation.expected.length = Expected truncation length -- {0}
jshell.err.truncation.length.not.integer = Truncation length must be an integer: {0} -- {1}

jshell.err.not.valid.with.predefined.mode = Not valid with a predefined mode: {0} -- {1}
jshell.err.retained.feedback.mode.must.be.retained.or.predefined = \
''/set feedback -retain <mode>'' requires that <mode> is predefined or has been retained with ''/set mode -retain'' -- {0}

jshell.err.unknown.option = Unknown option: {0} -- {1}
jshell.err.default.option.or.program = Specify -default option, -delete option, or program -- {0}
jshell.err.option.or.filename = Specify no more than one of -default, -none, or a startup file name -- {0}
jshell.err.unexpected.at.end = Unexpected arguments at end of command: {0} -- {1}
jshell.err.conflicting.options = Conflicting options -- {0}
jshell.err.cannot.delete.current.mode = The current feedback mode ''{0}'' cannot be deleted, use ''/set feedback'' first -- {1}
jshell.err.cannot.delete.retained.mode = The retained feedback mode ''{0}'' cannot be deleted, use ''/set feedback -retain'' first -- {1}
jshell.err.may.not.specify.options.and.snippets = Options and snippets must not both be used: {0}
jshell.err.no.such.snippets = No such snippet: {0}
jshell.err.the.snippet.cannot.be.used.with.this.command = This command does not accept the snippet ''{0}'' : {1}
jshell.err.retained.mode.failure = Failure in retained modes (modes cleared) -- {0} {1}

jshell.err.corrupted.stored.startup = Corrupted stored startup, using default -- {0}

jshell.console.see.synopsis = <press tab again to see synopsis>
jshell.console.see.full.documentation = <press tab again to see full documentation>
jshell.console.see.documentation = <press tab again to see documentation>
jshell.console.see.next.page = <press tab again to see next page>
jshell.console.see.next.javadoc = <press tab to see next documentation>
jshell.console.see.next.command.doc = <press tab to see next command>
jshell.console.no.such.command = No such command
jshell.console.completion.current.signatures = Signatures:
jshell.console.completion.all.completions.number = <press tab again to see all possible completions; total possible completions: {0}>
jshell.console.completion.all.completions = <press tab again to see all possible completions>
jshell.console.no.javadoc = <no documentation found>
jshell.console.do.nothing = Do nothing
jshell.console.choice = Choice: \

jshell.console.create.variable = Create variable
jshell.console.create.method = Create method
jshell.console.resolvable = \nThe identifier is resolvable in this context.
jshell.console.no.candidate = \nNo candidate fully qualified names found to import.
jshell.console.incomplete = \nResults may be incomplete; try again later for complete results.
jshell.console.erroneous = \nIncomplete or erroneous. A single valid expression or statement must proceed Shift-<tab> m.
jshell.console.exprstmt = \nA single valid expression or statement must proceed Shift-<tab> m.
jshell.console.empty = \nEmpty entry. A single valid expression or statement must proceed Shift-<tab> m..

jshell.fix.wrong.shortcut =\
Unexpected character after Shift-Tab.\n\
Use "i" for auto-import, "v" for variable creation, or "m" for method creation.\n\
For more information see:\n\
   /help shortcuts

help.usage = \
Usage:   jshell <option>... <load file>...\n\
where possible options include:\n\
\    --class-path <path>   Specify where to find user class files\n\
\    --module-path <path>  Specify where to find application modules\n\
\    --add-modules <module>(,<module>)*\n\
\                          Specify modules to resolve, or all modules on the\n\
\                            module path if <module> is ALL-MODULE-PATHs\n\
\    --startup <file>      One run replacement for the start-up definitions\n\
\    --no-startup          Do not run the start-up definitions\n\
\    --feedback <mode>     Specify the initial feedback mode. The mode may be\n\
\                            predefined (silent, concise, normal, or verbose) or\n\
\                            previously user-defined\n\
\    -q                    Quiet feedback.  Same as: --feedback concise\n\
\    -s                    Really quiet feedback.  Same as: --feedback silent\n\
\    -v                    Verbose feedback.  Same as: --feedback verbose\n\
\    -J<flag>              Pass <flag> directly to the runtime system.\n\
\                            Use one -J for each runtime flag or flag argument\n\
\    -R<flag>              Pass <flag> to the remote runtime system.\n\
\                            Use one -R for each remote flag or flag argument\n\
\    -C<flag>              Pass <flag> to the compiler.\n\
\                            Use one -C for each compiler flag or flag argument\n\
\    --version             Print version information and exit\n\
\    --show-version        Print version information and continue\n\
\    --help                Print this synopsis of standard options and exit\n\
\    --help-extra, -X      Print help on non-standard options and exit\n\
A file argument may be a file name, or one of the predefined file names: DEFAULT,\n\
PRINTING, or JAVASE.\n\
A load file may also be "-" to indicate standard input, without interactive I/O.\n

help.usage.x = \
\    --add-exports <module>/<package>   Export specified module-private package to snippets\n\
\    --execution <spec>                 Specify an alternate execution engine.\n\
\                                         Where <spec> is an ExecutionControl spec.\n\
\                                         See the documentation of the package\n\
\                                         jdk.jshell.spi for the syntax of the spec\n\
\    \n\
\These options are non-standard and subject to change without notice.\n

help.list.summary = list the source you have typed
help.list.args = [<name or id>|-all|-start]
help.list =\
Show the source of snippets, prefaced with the snippet id.\n\
\n\
/list\n\t\
    List the currently active snippets of code that you typed or read with /open\n\n\
/list -start\n\t\
    List the automatically evaluated start-up snippets\n\n\
/list -all\n\t\
    List all snippets including failed, overwritten, dropped, and start-up\n\n\
/list <name>\n\t\
    List snippets with the specified name (preference for active snippets)\n\n\
/list <id>\n\t\
    List the snippet with the specified snippet id\n\n\
/list <id> <id>...\n\t\
    List the snippets with the specified snippet ids\n\n\
/list <id>-<id>\n\t\
    List the snippets within the range of snippet ids

help.edit.summary = edit a source entry referenced by name or id
help.edit.args = <name or id>
help.edit =\
Edit a snippet or snippets of source in an external editor.\n\
The editor to use is set with /set editor.\n\
If no editor has been set, a simple editor will be launched.\n\
\n\
/edit <name>\n\t\
    Edit the snippet or snippets with the specified name (preference for active snippets)\n\n\
/edit <id>\n\t\
    Edit the snippet with the specified snippet id\n\n\
/edit <id> <id>...\n\t\
    Edit the snippets with the specified snippet ids\n\n\
/edit <id>-<id>\n\t\
    Edit the snippets within the range of snippet ids\n\n\
/edit -start\n\t\
    Edit the automatically evaluated start-up snippets. Any changes are in this\n\t\
    session, and do not affect the start-up setting\n\n\
/edit -all\n\t\
    Edit all snippets including failed, overwritten, dropped, and start-up\n\n\
/edit\n\t\
    Edit the currently active snippets of code that you typed or read with /open

help.drop.summary = delete a source entry referenced by name or id
help.drop.args = <name or id>
help.drop =\
Drop a snippet -- making it inactive.\n\
\n\
/drop <name>\n\t\
    Drop the snippet with the specified name\n\n\
/drop <id>\n\t\
    Drop the snippet with the specified snippet id\n\n\
/drop <id> <id>...\n\t\
    Drop the snippets with the specified snippet ids\n\n\
/drop <id>-<id>\n\t\
    Drop the snippets within the range of snippet ids

help.save.summary = Save snippet source to a file.
help.save.args = [-all|-history|-start] <file>
help.save =\
Save the specified snippets and/or commands to the specified file.\n\
\n\
/save <file>\n\t\
    Save the source of current active snippets to the file.\n\n\
/save -all <file>\n\t\
    Save the source of all snippets to the file.\n\t\
    Includes source including overwritten, failed, and start-up code.\n\n\
/save -history <file>\n\t\
    Save the sequential history of all commands and snippets entered since jshell was launched.\n\n\
/save -start <file>\n\t\
    Save the current start-up definitions to the file.\n\n\
/save <id> <file>\n\t\
    Save the snippet with the specified snippet id\n\n\
/save <id> <id>... <file>\n\t\
    Save the snippets with the specified snippet ids\n\n\
/save <id>-<id> <file>\n\t\
    Save the snippets within the range of snippet ids

help.open.summary = open a file as source input
help.open.args = <file>
help.open =\
Open a file and read its contents as snippets and commands.\n\
\n\
/open <file>\n\t\
    Read the specified file as jshell input.

help.vars.summary = list the declared variables and their values
help.vars.args = [<name or id>|-all|-start]
help.vars =\
List the type, name, and value of jshell variables.\n\
\n\
/vars\n\t\
    List the type, name, and value of the current active jshell variables\n\n\
/vars <name>\n\t\
    List jshell variables with the specified name (preference for active variables)\n\n\
/vars <id>\n\t\
    List the jshell variable with the specified snippet id\n\n\
/vars <id> <id>... <file>\n\t\
    List the jshell variables with the specified snippet ids\n\n\
/vars <id>-<id> <file>\n\t\
    List the jshell variables within the range of snippet ids\n\n\
/vars -start\n\t\
    List the automatically added start-up jshell variables\n\n\
/vars -all\n\t\
    List all jshell variables including failed, overwritten, dropped, and start-up

help.methods.summary = list the declared methods and their signatures
help.methods.args = [<name or id>|-all|-start]
help.methods =\
List the name, parameter types, and return type of jshell methods.\n\
\n\
/methods\n\t\
    List the name, parameter types, and return type of the current active jshell methods\n\n\
/methods <name>\n\t\
    List jshell methods with the specified name (preference for active methods)\n\n\
/methods <id>\n\t\
    List the jshell method with the specified snippet id\n\n\
/methods <id> <id>... <file>\n\t\
    List jshell methods with the specified snippet ids\n\n\
/methods <id>-<id> <file>\n\t\
    List jshell methods within the range of snippet ids\n\n\
/methods -start\n\t\
    List the automatically added start-up jshell methods\n\n\
/methods -all\n\t\
    List all snippets including failed, overwritten, dropped, and start-up

help.types.summary = list the declared types
help.types.args =[<name or id>|-all|-start]
help.types =\
List jshell classes, interfaces, and enums.\n\
\n\
/types\n\t\
    List the current active jshell classes, interfaces, and enums.\n\n\
/types <name>\n\t\
    List jshell types with the specified name (preference for active types)\n\n\
/types <id>\n\t\
    List the jshell type with the specified snippet id\n\n\
/types <id> <id>... <file>\n\t\
    List jshell types with the specified snippet ids\n\n\
/types <id>-<id> <file>\n\t\
    List jshell types within the range of snippet ids\n\n\
/types -start\n\t\
    List the automatically added start-up jshell types\n\n\
/types -all\n\t\
    List all jshell types including failed, overwritten, dropped, and start-up

help.imports.summary = list the imported items
help.imports.args =
help.imports =\
List the current active jshell imports.

help.exit.summary = exit jshell
help.exit.args =[<integer-expression-snippet>]
help.exit =\
Leave the jshell tool.  No work is saved.\n\
Save any work before using this command\n\
\n\
/exit\n\t\
    Leave the jshell tool.  The exit status is zero.\n\n\
/exit <integer-expression-snippet>\n\t\
    Evaluate the snippet.  If the snippet fails or is not an integer expression,\n\t\
    display the error.  Otherwise leave the jshell tool with the\n\t\
    value of the expression as the exit status

help.reset.summary = reset jshell
help.reset.args = \
[-class-path <path>] [-module-path <path>] [-add-modules <modules>]...
help.reset =\
Reset the jshell tool code and execution state:\n\t\
   * All entered code is lost.\n\t\
   * Start-up code is re-executed.\n\t\
   * The execution state is restarted.\n\t\
Tool settings are maintained, as set with: /set ...\n\
Save any work before using this command.\n\
The /reset command accepts context options, see:\n\n\t\
     /help context\n\


help.reload.summary = reset and replay relevant history -- current or previous (-restore)
help.reload.args = \
[-restore] [-quiet] [-class-path <path>] [-module-path <path>]...
help.reload =\
Reset the jshell tool code and execution state then replay each valid snippet\n\
and any /drop commands in the order they were entered.\n\
\n\
/reload\n\t\
     Reset and replay the valid history since jshell was entered, or\n\t\
     a /reset, or /reload command was executed -- whichever is most\n\t\
     recent.\n\n\
/reload -restore\n\t\
     Reset and replay the valid history between the previous and most\n\t\
     recent time that jshell was entered, or a /reset, /reload, or /env\n\t\
     command was executed. This can thus be used to restore a previous\n\t\
     jshell tool session.\n\n\
/reload [-restore] -quiet\n\t\
     With the '-quiet' argument the replay is not shown.  Errors will display.\n\
\n\
Each of the above accepts context options, see:\n\n\t\
     /help context\n\
\n\
For example:\n\n\t\
     /reload -add-modules com.greetings -restore

help.env.summary = view or change the evaluation context
help.env.args = \
[-class-path <path>] [-module-path <path>] [-add-modules <modules>] ...
help.env =\
View or change the evaluation context.  The evaluation context is the class path,\n\
module path, etc.\n\
/env\n\t\
     Show the evaluation context displayed as context options.\n\n\
/env [-class-path <path>] [-module-path <path>] [-add-modules <modules>] ...\n\t\
     With at least one option set, sets the evaluation context.  If snippets\n\t\
     have been defined, the execution state is reset with the new\n\t\
     evaluation context and the snippets will be replayed -- the replay is not\n\t\
     shown, however, errors will display.  This is equivalent to: /reload -quiet\n\t\
     For details of context options, see:\n\n\t\t\
           /help context\n\n\t\
     For example:\n\n\t\t\
           /env -add-modules com.greetings

help.history.summary = history of what you have typed
help.history.args =
help.history =\
Display the history of snippet and command input since this jshell was launched.

help.debug.summary = toggle debugging of the jshell
help.debug.args = [0][r][g][f][c][d][e]
help.debug =\
Display debugging information for the jshell implementation.\n\
0: Debugging off\n\
r: Tool level debugging on\n\
g: General debugging on\n\
f: File manager debugging on\n\
c: Completion analysis debugging on\n\
d: Dependency debugging on\n\
e: Event debugging on

help.help.summary = get information about jshell
help.help.args = [<command>|<subject>]
help.help =\
Display information about jshell.\n\
/help\n\t\
     List the jshell commands and help subjects.\n\n\
/help <command>\n\t\
     Display information about the specified command. The slash must be included.\n\t\
     Only the first few letters of the command are needed -- if more than one\n\t\
     each will be displayed.  Example:  /help /li\n\n\
/help <subject>\n\t\
     Display information about the specified help subject. Example: /help intro

help.set.summary = set jshell configuration information
help.set.args = editor|start|feedback|mode|prompt|truncation|format ...
help.set =\
Set jshell configuration information, including:\n\
the external editor to use, the start-up definitions to use, a new feedback mode,\n\
the command prompt, the feedback mode to use, or the format of output.\n\
\n\
/set editor [-wait] <command> <optional-arg>...\n\t\
     Specify the command to launch for the /edit command.\n\t\
     The <command> is an operating system dependent string.\n\n\
/set start <file>\n\t\
     The contents of the specified <file> become the default start-up snippets and commands.\n\n\
/set feedback <mode>\n\t\
     Set the feedback mode describing displayed feedback for entered snippets and commands.\n\n\
/set mode <mode> [<old-mode>] -command|-quiet|-delete\n\t\
     Create or update a user-defined feedback mode, optionally copying from an existing mode.\n\n\
/set prompt <mode> "<prompt>" "<continuation-prompt>"\n\t\
     Set the displayed prompts for a given feedback mode.\n\n\
/set truncation <mode> <length> <selector>...\n\t\
     Set the maximum length of a displayed value.\n\n\
/set format <mode> <field> "<format>" <selector>...\n\t\
     Configure a feedback mode by setting the format of a field when the selector matches.\n\n\
/set\n\t\
     Show editor, start, and feedback settings as /set commands.\n\t\
     To show the settings of any of the above, omit the set value.\n\n\
To get more information about one of these forms, use /help with the form specified.\n\
For example:   /help /set format

help.quest.summary = get information about jshell
help.quest.args = [<command>|<subject>]
help.quest =\
Display information about jshell (abbreviation for /help).\n\
/?\n\t\
     Display list of commands and help subjects.\n\
/? <command>\n\t\
     Display information about the specified command. The slash must be included.\n\t\
     Only the first few letters of the command are needed -- if more than one\n\t\
     match, each will be displayed.  Example:  /? /li\n\
/? <subject>\n\t\
     Display information about the specified help subject. Example: /? intro

help.bang.summary = rerun last snippet -- see /help rerun
help.bang.args =
help.bang =\
Reevaluate the most recently entered snippet.

help.id.summary = rerun snippets by id or id range -- see /help rerun
help.id.args =
help.id =\
/<id> <id> <id>\n\
\n\
/<id>-<id>\n\
\n\
Reevaluate the snippets specified by the id or id range.\n\
An id range is represented as a two ids separated by a hyphen, e.g.:  3-17\n\
Start-up and error snippets maybe used, e.g.:  s3-s9    or   e1-e4\n\
Any number of ids or id ranges may be used, e.g.:  /3-7 s4 14-16 e2

help.previous.summary = rerun n-th previous snippet -- see /help rerun
help.previous.args =
help.previous =\
Reevaluate the n-th most recently entered snippet.

help.intro.summary = an introduction to the jshell tool
help.intro =\
The jshell tool allows you to execute Java code, getting immediate results.\n\
You can enter a Java definition (variable, method, class, etc), like:  int x = 8\n\
or a Java expression, like:  x + x\n\
or a Java statement or import.\n\
These little chunks of Java code are called 'snippets'.\n\
\n\
There are also jshell commands that allow you to understand and\n\
control what you are doing, like:  /list\n\
\n\
For a list of commands: /help

help.shortcuts.summary = a description of keystrokes for snippet and command completion,\n\
information access, and automatic code generation
help.shortcuts =\
Supported shortcuts include:\n\
\n\
<tab>\n\t\t\
        After entering the first few letters of a Java identifier,\n\t\t\
        a jshell command, or, in some cases, a jshell command argument,\n\t\t\
        press the <tab> key to complete the input.\n\t\t\
        If there is more than one completion, then possible completions will be shown.\n\t\t\
        Will show documentation if available and appropriate.\n\n\
Shift-<tab> v\n\t\t\
        After a complete expression, hold down <shift> while pressing <tab>,\n\t\t\
        then release and press "v", the expression will be converted to\n\t\t\
        a variable declaration whose type is based on the type of the expression.\n\n\
Shift-<tab> m\n\t\t\
        After a complete expression or statement, hold down <shift> while pressing <tab>,\n\t\t\
        then release and press "m", the expression or statement will be converted to\n\t\t\
        a method declaration. If an expression, the return type is based on the type\n\t\t\
        of the expression.\n\n\
Shift-<tab> i\n\t\t\
        After an unresolvable identifier, hold down <shift> while pressing <tab>,\n\t\t\
        then release and press "i", and jshell will propose possible imports\n\t\t\
        which will resolve the identifier based on the content of the specified classpath.

help.context.summary = a description of the evaluation context options for /env /reload and /reset
help.context =\
These options configure the evaluation context, they can be specified when\n\
jshell is started: on the command-line, or restarted with the commands /env,\n\
/reload, or /reset.\n\
\n\
They are:\n\t\
    --class-path <class search path of directories and zip/jar files>\n\t\t\
                  A list of directories, JAR archives,\n\t\t\
                  and ZIP archives to search for class files.\n\t\t\
                  The list is separated with the path separator\n\t\t\
                  (a : on unix/linux/mac, and ; on windows).\n\t\
    --module-path <module path>...\n\t\t\
                  A list of directories, each directory\n\t\t\
                  is a directory of modules.\n\t\t\
                  The list is separated with the path separator\n\t\t\
                  (a : on unix/linux/mac, and ; on windows).\n\t\
    --add-modules <modulename>[,<modulename>...]\n\t\t\
                  root modules to resolve in addition to the initial module.\n\t\t\
                  <modulename> can also be ALL-DEFAULT, ALL-SYSTEM,\n\t\t\
                  ALL-MODULE-PATH.\n\t\
    --add-exports <module>/<package>=<target-module>(,<target-module>)*\n\t\t\
                  updates <module> to export <package> to <target-module>,\n\t\t\
                  regardless of module declaration.\n\t\t\
                  <target-module> can be ALL-UNNAMED to export to all\n\t\t\
                  unnamed modules. In jshell, if the <target-module> is not\n\t\t\
                  specified (no =) then ALL-UNNAMED is used.\n\
\n\
On the command-line these options must have two dashes, e.g.: --module-path\n\
On jshell commands they can have one or two dashes, e.g.: -module-path\n\

help.rerun.summary = a description of ways to re-evaluate previously entered snippets
help.rerun =\
There are four ways to re-evaluate previously entered snippets.\n\
The last snippet can be re-evaluated using: /!\n\
The n-th previous snippet can be re-evaluated by slash-minus and the digits of n, e.g.:  /-4\n\
For example:\n\
\n\
    \tjshell> 2 + 2\n\
    \t$1 ==> 4\n\
\n\
    \tjshell> /!\n\
    \t2 + 2\n\
    \t$2 ==> 4\n\
\n\
    \tjshell> int z\n\
    \tz ==> 0\n\
\n\
    \tjshell> /-1\n\
    \tint z;\n\
    \tz ==> 0\n\
\n\
    \tjshell> /-4\n\
    \t2 + 2\n\
    \t$5 ==> 4\n\
\n\
The snippets to re-evaluate may be specified by snippet id or id range.\n\
An id range is represented as a two ids separated by a hyphen, e.g.:  3-17\n\
Start-up and error snippets maybe used, e.g.:  s3-s9    or   e1-e4\n\
Any number of ids or id ranges may be used, e.g.:  /3-7 s4 14-16 e2\n\
\n\
Finally, you can search backwards through history by entering ctrl-R followed by the string to search for.

help.set._retain = \
The '-retain' option saves a setting so that it is used in future sessions.\n\
The -retain option can be used on the following forms of /set:\n\n\t\
/set editor -retain\n\t\
/set start -retain\n\t\
/set feedback -retain\n\t\
/set mode -retain\n\n\
See these commands for more detail -- for example /help /set editor

help.set.format.summary = \
Set the format for reporting a snippet event.

help.set.format = \
Set the format for reporting a snippet event:\n\
\n\t\
/set format <mode> <field> "<format>" <selector>...\n\
\n\
Show the format settings:\n\
\n\t\
/set format [<mode> [<field>]]\n\
\n\
Where <mode> is the name of a previously defined feedback mode -- see '/help /set mode'.\n\
Where <field> is the name of context-specific format to define.\n\
Where <format> is a quoted string which will be the value of the field if one of\n\
the selectors matches (or there are no selectors). When the format is used,\n\
field names enclosed in braces are replaced with the value of the field at that\n\
time. These fields may have been previously defined with this command or may be\n\
one of these predefined fields specific to the context:\n\t\
{name}       == The name, e.g.: the variable name, ...\n\t\
{type}       == The type name. The type of a variable or expression, the\n\t\t\t\
                 parameter types of a method\n\t\
{value}      == The result value of an expression or variable initialization\n\t\
{unresolved} == The list of unresolved references\n\t\
{errors}     == The list of recoverable errors (during the processing of the\n\t\t\t\
                "display" field only)\n\t\
{err}        == An unformatted error line (during the processing of the\n\t\t\t\
                "errorline" field only)\n\
The following fields are accessed by the tool to determine the displayed feedback:\n\t\
{display}    == The displayed message for a snippet event\n\t\
{errorline}  == The format of one error line within the "errors" field\n\t\
{pre}        == The feedback prefix (begins command feedback)\n\t\
{post}       == The feedback postfix (ends command feedback)\n\t\
{errorpre}   == The error prefix (begins error feedback)\n\t\
{errorpost}  == The error postfix (ends error feedback)\n\
These fields have default settings (which may be overwritten).\n\
Where <selector> is the context in which the format is applied.\n\
The structure of selector is a hyphen separated list of selector kind lists.\n\
A selector kind list is a comma separated list of values of one selector kind.\n\
A selector matches if each selector kind list matches; A selector kind list\n\
matches if one of the values matches.\n\n\
The case selector kind describes the kind of snippet.  The values are:\n\t\
   import     -- import declaration\n\t\
   class      -- class declaration\n\t\
   interface  -- interface declaration\n\t\
   enum       -- enum declaration\n\t\
   annotation -- annotation interface declaration\n\t\
   method     -- method declaration -- note: {type}==parameter-types\n\t\
   vardecl    -- variable declaration without init\n\t\
   varinit    -- variable declaration with init\n\t\
   expression -- expression -- note: {name}==scratch-variable-name\n\t\
   varvalue   -- variable value expression\n\t\
   assignment -- assign variable\n\t\
   statement  -- statement\n\
The action selector kind describes what happened to the snippet.  The values are:\n\t\
   added     -- snippet has been added\n\t\
   modified  -- an existing snippet has been modified\n\t\
   replaced  -- an existing snippet has been replaced with a new snippet\n\t\
   overwrote -- an existing snippet has been overwritten\n\t\
   dropped   -- snippet has been dropped\n\t\
   used      -- snippet was used when it cannot be\n\
The when-did-it-occur selector kind describes if this is a direct or indirect action.  The values are:\n\t\
   primary -- the entered snippet\n\t\
   update  -- an update to a dependent snippet\n\
The resolution-state selector kind describes the state of resolution/definition of the snippet.  The values are:\n\t\
   ok         -- resolved correctly\n\t\
   defined    -- defined despite recoverably unresolved references\n\t\
   notdefined -- not defined because of recoverably unresolved references\n\
The unresolved-count selector kind describes the number of unresolved references.  The values are:\n\t\
   unresolved0 -- no names are unresolved\n\t\
   unresolved1 -- one name is unresolved\n\t\
   unresolved2 -- two or more names are unresolved\n\
The errors-count selector kind describes the number of errors.  The values are:\n\t\
   error0 -- no errors\n\t\
   error1 -- one error\n\t\
   error2 -- two or more errors\n\n\
Examples:\n\t\
/set format mymode action 'Created' added-primary\n\t\
/set format mymode action 'Update replaced' replaced-update\n\t\
/set format mymode display '{pre}{action} class {name}{post}' class-ok\n\t\
/set format mymode display '{pre}{action} variable {name}, reset to null{post}' replaced-vardecl,varinit-ok-update\n\n\
Note that subsequent selectors for a field may overwrite some or all of previous used selectors -- last one wins\n\
\n\
The form without <format> shows the current format settings.\n\
When the <mode> is specified only the format settings for that mode are shown.\n\
When both the <mode> and <field> are specified only the format settings for that\n\
mode and field are shown.  Example:\n\t\
/set format mymode\n\
shows the format settings for the mode mymode\n

help.set.truncation.summary = \
Set the max length of a displayed value.

help.set.truncation = \
Set the max length of a displayed value:\n\
\n\t\
/set truncation <mode> <length> <selector>...\n\
\n\
Show the current truncation settings:\n\
\n\t\
/set truncation [<mode>]\n\
\n\
Where <mode> is the name of a previously defined feedback mode -- see '/help /set mode'.\n\
Where <length> is an unsigned integer representing a maximum length.\n\
Where <selector> is only needed if you wish to fine-tune value truncation length\n\
by context, <selector> is the context in which the truncation is applied.\n\
The structure of selector is a hyphen separated list of selector kind lists.\n\
A selector kind list is a comma separated list of values of one selector kind.\n\
A selector matches if each selector kind list matches; A selector kind list\n\
matches if one of the values matches.\n\n\
Below are the relevant selector kinds for truncation.\n\n\
The case selector kind describes the kind of snippet.  The values are:\n\t\
   vardecl    -- variable declaration without init\n\t\
   varinit    -- variable declaration with init\n\t\
   expression -- expression -- note: {name}==scratch-variable-name\n\t\
   varvalue   -- variable value expression\n\t\
   assignment -- assign variable\n\
The action selector kind describes what happened to the snippet.  The values are:\n\t\
   added     -- snippet has been added\n\t\
   modified  -- an existing snippet has been modified\n\t\
   replaced  -- an existing snippet has been replaced with a new snippet\n\
Examples:\n\t\
/set trunc mymode 80\n\t\
/set truncation mymode 45 expression\n\t\
/set truncation mymode 0 vardecl-modified,replaced\n\n\
Note that subsequent selectors for a field may overwrite some or all of previous used selectors -- last one wins\n\
\n\
The form without <length> shows the truncation settings.\n\
When the <mode> is specified only the truncation settings for that mode are shown.\n\
Example:\n\t\
/set truncation mymode\n\
shows the truncation settings for the mode mymode\n

help.set.feedback.summary = \
Set the feedback mode describing displayed feedback for entered snippets and commands.

help.set.feedback = \
Set the feedback mode describing displayed feedback for entered snippets and commands:\n\
\n\t\
/set feedback [-retain] <mode>\n\
\n\
Retain the current feedback mode for future sessions:\n\
\n\t\
/set feedback -retain\n\
\n\
Show the feedback mode and list available modes:\n\
\n\t\
/set feedback\n\
\n\
Where <mode> is the name of a previously defined feedback mode.\n\
You may use just enough letters to make it unique.\n\
User-defined modes can be added, see '/help /set mode'\n\
\n\
When the -retain option is used, the setting will be used in this and future\n\
runs of the jshell tool.\n\
\n\
The form without <mode> or -retain displays the current feedback mode and available modes.\n

help.set.mode.summary = \
Create a user-defined feedback mode, optionally copying from an existing mode.

help.set.mode = \
Create a user-defined feedback mode, optionally copying from an existing mode:\n\
\n\t\
/set mode <new-mode> [<old-mode>] (-command|-quiet)\n\
\n\
Retain a user-defined feedback mode for future sessions:\n\
\n\t\
/set mode -retain <mode>\n\
\n\
Delete a user-defined feedback mode:\n\
\n\t\
/set mode -delete [-retain] <mode>\n\
\n\
Show feedback mode settings:\n\
\n\t\
/set mode [<mode>]\n\
\n\
Where <new-mode> is the name of a mode you wish to create.\n\
Where <old-mode> is the name of a existing feedback mode.\n\
Where <mode> is the name of a existing feedback mode.\n\
\n\
If <old-mode> is present, its settings are copied to the new mode.\n\
\n\
The feedback that a mode provides for entered snippets is determined by the\n\
'/set format' settings. However, for entered commands, feedback is either on or off,\n\
as determined by the option used when creating the mode; Either the option '-command'\n\
or the option '-quiet' must be specified. If '-command' is used, informative and\n\
verifying command feedback is displayed when in the new mode.  If '-quiet' is used,\n\
commands give only essential feedback (e.g., errors).\n\
\n\
Once the new mode is created, use '/set format', '/set prompt' and '/set truncation'\n\
to configure it.  Use '/set feedback' to use the new mode.\n\
\n\
When the '-retain' option is used (without the '-delete' option), the mode (including\n\
its current prompt, format, and truncation settings) will be stored for use in\n\
future runs of the jshell tool.  If retain is not used, the mode is only defined in\n\
the current session. After updating the mode's settings, retain the mode again to\n\
preserve the updates across sessions.\n\
\n\
When only the '-delete' option is used, the mode is deleted from the current session.\n\
When both '-retain' and '-delete' are used, the mode is deleted from the current and\n\
future sessions.\n\
\n\
When the form without options is used, the mode settings are displayed.\n\
When the <mode> is specified, only the mode settings for that mode are shown.\n\
Note: the settings for the mode include the settings for prompt, format, and\n\
truncation.\n\
Example:\n\t\
/set mode mymode\n\
\n\
shows the mode, prompt, format, and truncation settings for the mode mymode

help.set.prompt.summary = \
Set the prompts.

help.set.prompt = \
Set the prompts.  Both the normal prompt and the continuation-prompt must be set:\n\
\n\t\
/set prompt <mode> \"<prompt>\" \"<continuation-prompt>\"\n\
\n\
Show the normal prompt and the continuation-prompts:\n\
\n\t\
/set prompt [<mode>]\n\
\n\
Where <mode> is the name of a previously defined feedback mode.\n\
Where <prompt> and <continuation-prompt> are quoted strings printed as input prompts;\n\
Both may optionally contain '%%s' which will be substituted with the next snippet id --\n\
note that what is entered may not be assigned that id, for example it may be an error or command.\n\
The continuation-prompt is used on the second and subsequent lines of a multi-line snippet.\n\
\n\
The form without <prompt> shows the currently set prompts.\n\
When the <mode> is specified only the prompts for that mode are shown.\n\
Example:\n\t\
/set prompt mymode\n\
shows the prompts set for the mode mymode\n

help.set.editor.summary =\
Specify the command to launch for the /edit command.

help.set.editor =\
Specify the command to launch for the /edit command:\n\
\n\t\
/set editor [-retain] [-wait] <command>\n\
\n\t\
/set editor [-retain] -default\n\
\n\t\
/set editor [-retain] -delete\n\
\n\
Retain the current editor setting for future sessions:\n\
\n\t\
/set editor -retain\n\
\n\
Show the command to launch for the /edit command:\n\
\n\t\
/set editor\n\
\n\
The <command> is an operating system dependent string.\n\
The <command> may include space-separated arguments (such as flags)\n\n\
If the -default option is specified, the built-in default editor will be used.\n\n\
If the -delete option is specified, previous settings are ignored -- the editor\n\
settings are initialized as when starting the jshell tool.  Specifically, if there\n\
is a retained setting it is used (unless both -retain and -delete are specified --\n\
which deletes the retained setting), if one of these environment variables is set\n\
it will be used: JSHELLEDITOR, VISUAL, or EDITOR (in that order).  Otherwise the\n\
built-in default editor will be used.\n\n\
If <command> is specified, it will be used as the external editor. The <command>\n\
consists of the program and zero or more program arguments.  When <command>\n\
is used, the temporary file to edit will be appended as the last argument.\n\
Normally, edit mode will last until the external editor exits. Some external editors\n\
will exit immediately (for example, if the edit window exists) either external editor\n\
flags should be used to prevent immediate exit, or the -wait option should be used to\n\
prompt the user to indicate when edit mode should end.\n\n\
Note: while in edit mode no command inputs are seen.  After leaving edit mode changes\n\
to the edited snippets are not seen.\n\
\n\
When the -retain option is used, the setting will be used in this and future\n\
runs of the jshell tool.\n\
\n\
The form without <command> or options shows the editor setting.\n

help.set.start.summary =\
Set the start-up configuration.

help.set.start =\
Set the start-up configuration -- a sequence of snippets and commands read at start-up:\n\
\n\t\
/set start [-retain] <file>...\n\
\n\t\
/set start [-retain] -default\n\
\n\t\
/set start [-retain] -none\n\
\n\
Retain the start-up configuration for future sessions:\n\
\n\t\
/set start -retain\n\
\n\
Show the start-up setting:\n\
\n\t\
/set start\n\
\n\
The contents of the specified <file> become the start-up snippets and commands used\n\
when the /reset, /reload, or /env commands are used in this session.\n\
If instead the -default option is specified, the predefined start-up import\n\
snippets will be used.\n\
If the -none option is used, the start-up will be empty -- no start-up snippets\n\
or commands will be used.\n\
This command is good for testing the start-up settings.  To retain them for future\n\
runs of the jshell tool use the command:\n\t\
/set start -retain\n\
\n\
When the -retain option is used, the setting will be used in this and future\n\
runs of the jshell tool.\n\
\n\
The form without <file> or options shows the start-up setting.\n\
Note: if the start-up was last set from a file, this is shown with the\n\
'set start' command followed by the contents of the file.\n\
\n\
The <file> may be an operating system file name, or one of the predefined\n\
startup file names: DEFAULT, PRINTING, or JAVASE.\n\
These are respectively: the default import snippets (as used by -default),\n\
definitions of print(), println(), and printf() method snippets, or\n\
imports of all Java SE packages.\n\
More than one <file> may be specified, for example:\n\
\n\t\
/set start -retain DEFAULT PRINTING

startup.feedback = \
/set mode verbose -command    \n\
\n\
/set prompt verbose '\\njshell> '   '   ...> '    \n\
\n\
/set format verbose pre '|  '    \n\
/set format verbose post '%n'    \n\
/set format verbose errorpre '|  '    \n\
/set format verbose errorpost '%n'    \n\
\n\
/set format verbose errorline '{post}{pre}    {err}'    \n\
\n\
/set format verbose action 'created' added-primary    \n\
/set format verbose action 'modified' modified-primary    \n\
/set format verbose action 'replaced' replaced-primary    \n\
/set format verbose action 'overwrote' overwrote-primary    \n\
/set format verbose action 'dropped' dropped-primary    \n\
/set format verbose action '  update created' added-update    \n\
/set format verbose action '  update modified' modified-update    \n\
/set format verbose action '  update replaced' replaced-update    \n\
/set format verbose action '  update overwrote' overwrote-update    \n\
/set format verbose action '  update dropped' dropped-update    \n\
\n\
/set format verbose until ', however, it cannot be instantiated or its methods invoked until'   defined-class-primary    \n\
/set format verbose until ', however, its methods cannot be invoked until'                      defined-interface-primary    \n\
/set format verbose until ', however, it cannot be used until'                                  defined-enum,annotation-primary    \n\
/set format verbose until ', however, it cannot be invoked until'                               defined-method-primary    \n\
/set format verbose until ', however, it cannot be referenced until'                            notdefined-primary    \n\
/set format verbose until ' which cannot be instantiated or its methods invoked until'          defined-class-update    \n\
/set format verbose until ' whose methods cannot be invoked until'                              defined-interface-update    \n\
/set format verbose until ' which cannot be invoked until'                                      defined-method-update    \n\
/set format verbose until ' which cannot be referenced until'                                   notdefined-update    \n\
\n\
/set format verbose unrerr '{unresolved} is declared'                                           unresolved1-error0    \n\
/set format verbose unrerr '{unresolved} are declared'                                          unresolved2-error0    \n\
/set format verbose unrerr ' this error is corrected: {errors}'                                 unresolved0-error1    \n\
/set format verbose unrerr '{unresolved} is declared and this error is corrected: {errors}'     unresolved1-error1    \n\
/set format verbose unrerr '{unresolved} are declared and this error is corrected: {errors}'    unresolved2-error1    \n\
/set format verbose unrerr ' these errors are corrected: {errors}'                              unresolved0-error2    \n\
/set format verbose unrerr '{unresolved} is declared and these errors are corrected: {errors}'  unresolved1-error2    \n\
/set format verbose unrerr '{unresolved} are declared and these errors are corrected: {errors}' unresolved2-error2    \n\
\n\
/set format verbose resolve '{until}{unrerr}'                                                   defined,notdefined-added,modified,replaced,used    \n\
\n\
/set format verbose typeKind 'class'                  class    \n\
/set format verbose typeKind 'interface'              interface    \n\
/set format verbose typeKind 'enum'                   enum    \n\
/set format verbose typeKind 'annotation interface'   annotation    \n\
\n\
/set format verbose result '{name} ==> {value}{post}'                                        added,modified,replaced-ok-primary    \n\
\n\
/set format verbose display '{result}{pre}created scratch variable {name} : {type}{post}'    expression-added,modified,replaced-primary    \n\
/set format verbose display '{result}{pre}value of {name} : {type}{post}'                    varvalue-added,modified,replaced-primary    \n\
/set format verbose display '{result}{pre}assigned to {name} : {type}{post}'                 assignment-primary    \n\
/set format verbose display '{result}{pre}{action} variable {name} : {type}{resolve}{post}'  varinit,vardecl    \n\
/set format verbose display '{pre}{action} variable {name}{resolve}{post}'                   vardecl,varinit-notdefined    \n\
/set format verbose display '{pre}{action} variable {name}{post}'                            dropped-vardecl,varinit,expression    \n\
/set format verbose display '{pre}{action} variable {name}, reset to null{post}'             replaced-vardecl,varinit-ok-update    \n\
\n\
/set format verbose display '{pre}{action} {typeKind} {name}{resolve}{post}'                 class,interface,enum,annotation    \n\
/set format verbose display '{pre}{action} method {name}({type}){resolve}{post}'             method    \n\
\n\
/set format verbose display '{pre}attempted to use {typeKind} {name}{resolve}{post}'         used-class,interface,enum,annotation    \n\
/set format verbose display '{pre}attempted to call method {name}({type}){resolve}{post}'    used-method    \n\
\n\
/set truncation verbose 80\n\
/set truncation verbose 1000                                                                  varvalue,expression\n\
\n\
/set mode normal -command verbose    \n\
/set format normal display ''                                                               added,modified,replaced,overwrote,dropped-update    \n\
/set format normal display '{pre}{action} variable {name}, reset to null{post}'             replaced-vardecl,varinit-ok-update    \n\
/set format normal display '{result}'                                                       added,modified,replaced-expression,varvalue,assignment,varinit,vardecl-ok-primary    \n\
/set mode concise -quiet normal    \n\
\n\
/set prompt concise 'jshell> '   '   ...> '    \n\
\n\
/set format concise display ''                                                              class,interface,enum,annotation,method,assignment,varinit,vardecl-ok    \n\
\n\
/set feedback normal    \n\
\n\
/set mode silent -quiet    \n\
/set prompt silent '-> ' '>> '    \n\
/set truncation silent 80\n\
/set truncation silent 1000                                                                  varvalue,expression\n\
/set format silent pre '|  '    \n\
/set format silent post '%n'    \n\
/set format silent errorpre '|  '    \n\
/set format silent errorpost '%n'    \n\
/set format silent display ''    \n
